#!/bin/bash 

#PARALLEL_JOBS=8
PARALLEL_JOBS=8

project=${1:-Tizen:Common}
#srv=https://api.tizen.org
srv=https://obs.vannes
path="/home/kthierry/jumbo/review.tizen.org"
here=`pwd`
log="$here/error.log"
rm -f $log

function parallel_jobs {
	local max_number=$((0 + ${1:-0}))
	while true; do
		jobs &>/dev/null
		if [[ $(jobs -p | wc -l) -lt $max_number ]]; then
			break
		fi
		sleep 0.3
	done
}

function get_git_infos() {
	local pkgname=$1
	local repo=$2
	local rev=$3
	local license=$4

	if [ "$repo" != "" -a -e $path/$repo ]; then
		pushd $path/$repo &> /dev/null
	else
		echo "Error: repo \"$repo\" for package \"$pkgname\" doesn't exist." >> $log
		return 1
	fi

	if [ "`git branch -r | grep origin/upstream`" ]; then
		# Upstream package, let's find the upstream tag
		# Get the version in spec file
		local upstreamversion=`grep Version: packaging/*.spec | awk '{print $2;}' | head -n 1`
		local upstream_version=$upstreamversion
		if [ -e .gbs.conf ]; then
			# Use the tag defined in .gbs.conf
			local tag=$(eval echo `grep upstream_tag .gbs.conf | awk '{print $3;}'`)
		else
			# Use tag generated by pristine-tar
			local tag="upstream/$upstreamversion"
		fi

		# Get the revision of the upstream tag
		if [ "`git tag | grep "$tag" --`" ]; then
			firstrev=`git log --pretty=format:"%H" -n 1 $tag --`
		else
			# No upstream tag: use all commits
			echo "Warning: no upstream tag \"$tag\" found for \"$pkgname\", using all commits" >> $log
			firstrev=`git rev-list HEAD | tail -n 1`
		fi

	else
		# Tizen packages: all commits are taken into account so first commit is the initial one
		firstrev=`git rev-list HEAD | tail -n 1`
	fi

	# List of the authors per commit
	logs=`git log $firstrev..$rev --pretty=format:"%ae"`

	local intelcommits=`echo $logs | sed 's/ /\n/g' | grep -Ec "intel"`
	local eurogicielcommits=`echo $logs | sed 's/ /\n/g' | grep -Ec "eurogiciel|fridu"`
	local totalcommits=`echo $logs | sed 's/ /\n/g' | wc -l`

	echo "$pkgname;$repo;$license;$eurogicielcommits;$intelcommits;$totalcommits"
}

function get_pkg_infos() {
	local srv=$1
	local project=$2
	local pkgname=$3

	local tmpfile=$(mktemp)
	trap "rm -f $tmpfile" STOP INT QUIT EXIT

	osc -A $srv list -e $project $pkgname >$tmpfile 2>/dev/null
	[[ $? -ne 0 ]] && return 1

	# find spec file name
	osc -A $srv cat $project $pkgname $(egrep "\.spec$" $tmpfile) >$tmpfile 2>/dev/null
	repo=$(grep VCS: $tmpfile | awk '{print $2;}' | cut -f1 -d'#')
	rev=$(grep VCS: $tmpfile | awk '{print $2;}' | cut -f2 -d'#')
	license=$(grep License: $tmpfile | sed 's/License:[ \t]*//g' | awk '{printf("%s/",$0);}' | sed 's|/$||g')
	get_git_infos $pkgname $repo $rev $license

	return 0
}

for pkg in $(osc -A $srv ls $project); do
	parallel_jobs $PARALLEL_JOBS
	get_pkg_infos $srv $project $pkg &
done

parallel_jobs 1